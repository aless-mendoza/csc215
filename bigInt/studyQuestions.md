# Study Questions

## Page 6
### 1. What are the largest and smallest integer values in the programming environment you use?**

- The largest is 32767 and the smallest is -32767

### 2. Each BigInt object will need to store the digits that represent the BigInt value. The decision to allow arbitrarily large BigInt values affects the choices for storing digits. Name one method for storing digits that will permit an arbitrary number of digits to be stored. What effect would a limit on the number of digits in a BigInt have in the design of the BigInt class?**

- One method is to used vectors which allow for dynamically sized datat structures (allows # of digits to grow as needed). If a limit on the number of digits were placed on BigInt, the class wouldn't have the ability to hold very large numbers.

### 3. Based on your knowledge of pencil-and-paper methods for doing arithmetic, what do you think will be the most difficult arithmetic operation (+, *, -) to implement for the BigInt class? Why?

- I think multiplication would be the most difficult, specifically of multi digit numbers. This is because it's repeated arithmetic, you have to track carried numbers, and the number continually grows.

### 4. Experiment with the calculator. If you enter abcd1234 when a number is expected, what happens? If you enter 1234abcd is the behavior different? What happens if you enter an operator that’s not one of the three that are implemented?

- When you enter abcd1234, you don't acutally get past a. Instead the calculator reads it as a 0. If you enter 1234abcd, you don't get past the numbers cause it automatically enters. If you put in an incorrect operator, it continually prompts you for another.

### 5. List as many operations as you can that are performed on integers, but that are not included in the list of BigInt functions and operators above.

- mod, exponent, bitwise

### 6. (AB only) What implementation decisions would require providing a destructor, a copy constructor, and an assignment operator?

- These are necessary when a class manages dynamic memory or shared resources

### 7. Consider the headers for operator- and operator+ given below.
```
BigInt operator - (const BigInt & big, int small);
// postcondition: returns big - small
BigInt operator + (const BigInt & big, int small);
// postcondition: returns big + small
```
Write the body of operator- assuming that operator+ has been written

- ???

## Page 10
### 1. Consider the error handling provided by your C++ system. What does the system do if a file is not present in a call to open? What happens on integer overflow or divide by zero? Determine which method(s) are used and discuss the relative desirability of other options.

- Generally when the file isn't found, the file stream will fail but the program continues unless the error is check. Integer overflow is silent (no error message) and produces and incorrect result. Both of these solutions prioritize performance over safety, however exceptions can be used to better handle errors.

### 2. List several errors that might be generated by BigInt operations and develop a declaration for an enumerated type (enum) to hold the errors.

- Errors can occur when there is an invalid input, division by 0, overflow during type conversion, or operation on uninitialized vars. Enumerated type can be used to show these different error conditions

### 3. Some systems allow error checking to be “turned off” entirely for greater speed. Under what circumstances is this approach preferred?

- This is preffered when speed and performance is critical and the inputs are guaranteed to be valid. This is often used in low-level or performance sensitive code

### 4. Consider another method for handling errors:
Use an interactive error-handling approach. An error message is displayed to the user who then has the option of (a) correcting the value that caused the error, (b) halting the program, or (c) ignoring the error. <br>
Describe the strengths and weaknesses of this approach.

- **Strength:** User friendly: the user will be able to immediately fix their error. Additionally, this makes the program more robust to invalid inputs and flexible for users
- **Weakness:** Makes automation and debugging more difficult since errors require user input to resolve. Additionally, this means that the program assumes the human will be present which limits the contexts that the program can be used in.

### 5. Consider another method for handling errors:
Error results are stored in a single global variable. This is set initially to indicate a “no error” condition. Whenever an error is detected, the global variable is set to an appropriate value, and the client program is responsible for examining the value of the
global variable. <br>
Describe the strengths and weaknesses of this approach.

- **Strength:** This allows the program to continue running which gives more control over how and when to respond to errors. It also is very simple
- **Weakness:** The client needs to remember to check the variable after operations, if not done the error can continue to quietly exist and inhibit other aspects of the program. It also means that the program isn't self encapsulated and requires external correcting. Lastly, it does scale well as it's easy to lose what caused the error to begin with

## Page 17
### 1. Why is a char vector used to store digits rather than an int vector? How will a change in the kind of element stored in the vector affect the implementation of all BigInt member functions.

- Ints are larger than chars so saving larger numbers as a char is smaller than as an int. If the type changes, only the digit access helper functions need to be updates

### 2. We have chosen an enum for storing the sign of a BigInt. Describe two alternatives or types other than an enum that can be used to represent the sign of a BigInt.

- the sign of BigInt could also be represented as a boolean value or an int with +1 or -1

### 3. Write the function GetDigit based on the description and declarations in this section. What kinds of error should you worry about?

- 

### 4. Why will it be difficult to write the non-member functions operator == and operator < given the current method for accessing digits using GetDigit? Write the function operator == for positive BigInt values assuming that NumDigits and GetDigit are public member functions.

- Its difficult because digits are accessed indirectly through helper functions. To compare two BigInt values, the num of digits must be compared first, followed by a digit by figit comparison from the most sig digit to least

### 5. (optional) Why is the apvector class a much better choice than the built-in array type given the specification of the BigInt class?

- The apvector class is a better choice because it automatically manages memory, resizes dynamically, and reduces the risk of memory errors


